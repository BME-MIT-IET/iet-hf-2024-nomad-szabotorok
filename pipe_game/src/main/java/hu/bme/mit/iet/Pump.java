package hu.bme.mit.iet;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sivatagi vizhalozat
//  @ File Name : Pump.java
//  @ Date : 14/04/2023
//  
//
//


import java.util.ArrayList;

/**
 * SystemPart, amely a víz áthelyezésére használható:
 * egy beállított csőből kiszívja a vizet,
 * és egy szintén beállított csőbe bele tol annyit amennyi belefér.
 * Maximum 4 cső csatlakozhat hozzá.
 * El tud romlani.
 */
public class Pump extends SystemPart {
	protected static int idNum = 0;
	private boolean broken = false;
	private int water = 0;
	private int capacity = 50;
	private Pipe from;
	private Pipe to;

	/**
	 * Konstruktor, ami beállítja az id-t az osztály nevére és egy eltérő számra
	 * Emellet ha kap két csövet akkor az beállítja be és kimenetnek
	 */
	public Pump(Pipe f, Pipe t){
		from = f;
		to = t;
		id = "pump " + idNum++;
	}
	public Pump(){this(null,null);}

	/**
	 * Beallit uj pumpalasi iranyt
	 * Ha rosszul lett megadva a from és to cső akkor sikertelen
	 * @param from Az uj cso amibol vizet sziv a pumpa
	 * @param to az uj cso amibe vezet tol a pumpa
	 * @return ha sikeres a muvelet true-val ter vissza egyébként false
	 */
	@Override
	public boolean AcceptNewFlow(Pipe from, Pipe to) {
		if(from.equals(to)) {
			return false;
		}
		this.from = from;
		this.to = to;
		return true;
	}

	/**
	 * Megjavítja az eltorott pumpat
	 */
	@Override
	public void Repair() {
		broken = false;
	}

	/**
	 * Beszívja a vizet a from csőből
	 * Ezt úgy éri el, hogy
	 *
	 * Ez nem tudom működik-e de lehet nagyon túlbonyolítottam
	 *
	 * @return visszatér a beszívott víz mennyiségével
	 */
	@Override
	public int PullWater() {
		if (broken) {
			return 0;
		}
		if (from == null) {
			return 0;
		}
		if (from.isBroken()) {
			return 0;
		}

		int fromWater = from.getWater();	//lekérdezzük mennyi vizet tudunk beszívni
		int canFit = capacity - water;		//megnézzük menniy üres hely van a pumpában
		int w = canFit - fromWater;			//kivonjuk a szabad helyből a bejövő vizet
		//ha ez NEM negatív az azt jelenti hogy befér az összes beszívható/csőben lévő víz
		//ha negatív akkor pedig annyi vizet szívunk be amennyi befér
		int pulled = w >= 0 ? fromWater : canFit;	//így megkapjuk a tényleges beszívott vizet

		water += pulled;
		from.setWater(from.getCapacity()-pulled);
		return 0;
	}

	/**
	 * Kipumpálja a vizet a to csobe
	 * @return visszatér a lyukas csövön kifolyt vízzel
	 */
	@Override
	public int PushWater() {
		if (broken) {
			return 0;
		}
		if (to == null) {
			return 0;
		}
		if (to.isBroken()) {
			return to.getCapacity();
		}

		int toWater = to.getWater();			//mennyi víz van a csőben
		int canFit = to.getCapacity() - toWater;//menyi víz fér még bele
		//ha a pumpában több víz van mint amennyi befér a csőbe akkor telepumpáljuk a csövet
		//ha kevesebb akkor annyit pumpálunk amenyi vizünk van
		int pushed = water >= canFit ? canFit : water;

		water -= pushed;
		to.setWater(toWater+pushed);
		return 0;
	}

	/**
	 * Eltori a pumpat
	 */
	@Override
	public void BreakPump() {
		broken = true;
	}

	/**
	 * Kulonbozo setterek, getterek lekerdezesre
	 */
	@Override
	public boolean isBroken() {
		return broken;
	}

	@Override
	public String getFrom(){
		if (from == null)
			return null;
		return from.getId();
	}

	@Override
	public String getTo(){
		if (to == null)
			return null;
		return to.getId();
	}
}
