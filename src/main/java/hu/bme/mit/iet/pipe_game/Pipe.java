package hu.bme.mit.iet.pipe_game;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sivatagi vizhalozat
//  @ File Name : Pipe.java
//  @ Date : 14/04/2023
//  
//
//

/**
 * A cső egy passzív elem
 * aktív elemek tudnak belepumpálni illetve kiszívni vizet
 * broken - lyukas-e a cső, ha igen akkor nem végig, hanem a sivatagba folyik a víz
 * carried - hordozza-e éppen valaki
 * water - a csőben lévő vízmenyiség
 * capacity - a cső maximális kapacitása
 */
public class Pipe extends SystemPart {
	protected static int idNum = 0;
	private boolean broken = false;
	private boolean carried = false;
	private int water = 0;
	private int capacity;
	int timeTillNewBreak = 0;
	enum State {NORMAL, SLIPPERY, STICKY}
	State currentState = State.NORMAL;

	/**
	 * Konstruktor, ami beállítja az id-t az osztály nevére és egy eltérő számra
	 */
	public Pipe(){
		this.capacity = 5;
		id = "pipe " + idNum++;
	}

	/**
	 * Konstruktor, ami beállítja az id-t az osztály nevére és egy eltérő számra
	 * @param capacity Beállítja az egyedi kapacitást erre az értékre
	 */
	public Pipe(int capacity){
		this.capacity = capacity;
		id = "Pipe " + idNum++;
	}

	/** ezeket a setter gettereket fel kell pusholni a systemPartba is de ott nem valósítjuk meg
	 *
	 */
	@Override
	void setGlued() {currentState=State.STICKY;}
	@Override
	void setSlippery() {currentState=State.SLIPPERY;}
	boolean isSlippery() {return currentState==State.SLIPPERY;}
	boolean isGlued() {return currentState==State.STICKY;}
	void setNormal() {currentState=State.NORMAL;}
	@Override
	public boolean isBroken() {
		return broken;
	}
	@Override
	public int getWater(){
		return water;
	}
	@Override
	public void setWater(int w){
		water = w;
	}
	@Override
	public int getCapacity(){
		return capacity;
	}
	@Override
	public void setCarried(boolean c){ carried = c;	}
	public void decTimeTillNewBreak() {
		if (timeTillNewBreak > 0)
			timeTillNewBreak--;
	}


	/**
	 * Kilyukasztja a csovet
	 */
	@Override
	public void BreakPipe() {
		if (timeTillNewBreak != 0)
			return;
		broken = true;
		Control.setSaboteurPoints(Control.getSaboteurPoints() + getWater());
		water = 0;
	}

	/**
	 * Megjavitja a csovet
	 * és beállítja hogy 2 körig nem törhet el
	 */
	@Override
	public void Repair() {
		broken = false;
		timeTillNewBreak = 2;
	}

	/**
	 * Ebben az osztályban nem működik
	 * @param whichEnd aktív elem, amelyik szomszédnál felvették a cső végét
	 */
	@Override
	public boolean CarryPipeEnd(SystemPart whichEnd) {
		return false;
	}

	/**
	 * Csak a többi elemben működik
	 * @param pipe az a cső amit lehelyezünk
	 * @return false itt nem működik
	 */
	@Override
	public boolean LayPipe(SystemPart pipe) {
		return false;
	}

	/**
	 * Lehelyez egy pumpát a cső közepére kettévágva a csövet
	 * Ezt úgy valósítja meg hogy a cső egyik végére berakja az új pumpát
	 * és az új pumpa és a régi aktív elem közé egy új csövet köt be
	 * a pumpa lerakása után beállítja a a pumpálási irányt???
	 * FONTOS a szomszédok beállításának sorrendje!
	 * @param pump a lerakandó pumpa
	 * @return ez lehetne void nem?
	 */
	@Override
	public boolean LayPump(SystemPart pump) {
		pump.AddNeighbour(this);

		Pipe newPipe = new Pipe();
		Control.addPipe(newPipe);
		pump.AddNeighbour(newPipe);

		//olvashatóság és hatékonyság érdekében
		SystemPart exneighbour = neighbours.get(0);

		exneighbour.RemoveNeighbour(this);
		exneighbour.AddNeighbour(newPipe);

		newPipe.AddNeighbour(pump);
		newPipe.AddNeighbour(exneighbour);

		RemoveNeighbour(exneighbour);
		AddNeighbour(pump);

		return true; // ez a fgv már lehetne void mert a mechanicnál teszteljük hogy va e nála pumpa itt már nem hasalhat el a művelet
	}

	/**
	 * Ha még senki nem áll a csövön és nem mozgatják a csövet,
	 * akkor szabad a cső és rá lépti a játékost
	 * ha a cső csúszós akkor továbbcsúszik a játékos valamelyik irányba
	 * ha pedig ragadós akkor odaragad a játékos
	 * ha nem szabad a cső akkor sikertelen a játékos mozgása
	 * @param mover a játékos, aki a csőre szeretne lépni
	 * @return sikeres volt-e a csőre lépés
	 */
	@Override
	public boolean AcceptPlayer(Player mover) {
		if (carried){
			return false;
		}
		if(!players.isEmpty()) {
			return false;
		}
		if (currentState == State.SLIPPERY) {
			currentState=State.NORMAL;
			return neighbours.get(0).AcceptPlayer(mover);
		}
		players.add(mover);
		if (currentState == State.STICKY) {
			mover.setGlued(1);
			currentState=State.NORMAL;
		}
		return true;
	}
}
